"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var debounce_1 = require("./debounce");
var request_1 = require("./request");
var SplunkEvents = /** @class */ (function () {
    function SplunkEvents() {
        var _this = this;
        this.events = [];
        this.pendingEvents = [];
        this.flushPending = false;
        /**
         * Logs an event to Splunk.
         *
         * This method will send the data to the Splunk endpoint configured
         * in the {@link SplunkEvent#config} method. For now, you can only
         * send primitive types such as string, numbers and booleans in the
         * event data object.
         *
         * @argument level Level of criticity of this log, use values such as
         * "Critical", "Important" or "Debug"
         * @argument type Type of this log, use values such as "Error", "Warn"
         * or "Info"
         * @argument workflowType Type of this "workflow", you can use something
         * related to your application domain, such as "checkout" for events happening
         * in the Checkout page.
         * @argument workflowInstance A more fine-grained level of information
         * regarding the workflow, use values such as "checkout-cart" for events
         * that happened in the Cart page of Checkout for example.
         * @argument eventData Any custom event data you may find useful to log
         * together that can provide more information.
         * @argument account In multi-tenant environment it can be useful to know
         * the exact account this event is happening in.
         */
        this.logEvent = function (level, type, workflowType, workflowInstance, eventData, account) {
            var _a;
            if (account === void 0) { account = ''; }
            _this.validateEvent(eventData);
            var eventObj = __assign(__assign({ level: level,
                type: type,
                workflowType: workflowType,
                workflowInstance: workflowInstance,
                account: account }, eventData), (_this.injectAdditionalInfo ? _this.getAdditionalInfo() : {}));
            var event = _this.shouldParseEventData
                ? _this.parseEventData(eventObj)
                : eventObj;
            var data = __assign(__assign({ sourcetype: _this.source, host: _this.host }, (_this.injectTimestamp && { time: +new Date() })), { event: event });
            _this.events.push(data);
            if (_this.autoFlush) {
                (_a = _this.debouncedFlush) === null || _a === void 0 ? void 0 : _a.call(_this);
            }
        };
        /**
         * Flushes pending events into one single request.
         *
         * You won't need to use this function unless you configured
         * this instance to not auto flush the events.
         */
        this.flush = function () {
            var _a;
            if (_this.isSendingEvents) {
                _this.flushPending = true;
                return;
            }
            _this.validateConfig();
            _this.pendingEvents = Array.from(_this.events);
            _this.events = [];
            _this.isSendingEvents = true;
            if (_this.debug) {
                console.log("sending " + _this.pendingEvents.length + " events to splunk");
            }
            if (_this.pendingEvents.length === 0) {
                return;
            }
            var splunkBatchedFormattedEvents = _this.formatEventsForSplunkBatch(_this.pendingEvents);
            _this.request({
                url: "" + _this.endpoint + _this.path,
                method: 'POST',
                data: splunkBatchedFormattedEvents,
                headers: (_a = _this.headers) !== null && _a !== void 0 ? _a : {},
                responseType: 'json'
            })
                .then(function () {
                if (_this.debug) {
                    console.log(_this.pendingEvents.length + " events successfuly sent to splunk");
                }
                _this.pendingEvents = [];
                _this.isSendingEvents = false;
                if (_this.flushPending) {
                    _this.flushPending = false;
                    return _this.flush();
                }
            })["catch"](function (e) {
                var _a;
                _this.events = _this.events.concat(_this.pendingEvents);
                _this.pendingEvents = [];
                _this.isSendingEvents = false;
                if (_this.autoRetryFlush) {
                    if (_this.debug) {
                        console.warn('Error sending events to splunk. Retrying in 5 seconds.', e);
                    }
                    (_a = _this.debouncedFlush) === null || _a === void 0 ? void 0 : _a.call(_this);
                }
                else if (_this.debug) {
                    console.warn('Error sending events to splunk.', e);
                }
            });
        };
    }
    /**
     * Configure (or reconfigure) this Splunk Event instance.
     */
    SplunkEvents.prototype.config = function (config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        this.events = this.events || [];
        this.pendingEvents = this.pendingEvents || [];
        this.isSendingEvents = (_a = this.isSendingEvents) !== null && _a !== void 0 ? _a : false;
        this.endpoint = config.endpoint; // required
        this.token = config.token; // required
        this.injectAdditionalInfo = (_c = (_b = config.injectAditionalInfo) !== null && _b !== void 0 ? _b : config.injectAdditionalInfo) !== null && _c !== void 0 ? _c : false;
        this.autoFlush = (_d = config.autoFlush) !== null && _d !== void 0 ? _d : true;
        this.autoRetryFlush = (_e = config.autoRetryFlush) !== null && _e !== void 0 ? _e : true;
        this.source = (_f = config.source) !== null && _f !== void 0 ? _f : 'log';
        this.path = (_g = config.path) !== null && _g !== void 0 ? _g : '/services/collector/event';
        this.host = (_h = config.host) !== null && _h !== void 0 ? _h : '-';
        this.debug = (_j = config.debug) !== null && _j !== void 0 ? _j : false;
        this.debounceTime = (_l = (_k = config.debounceTime) !== null && _k !== void 0 ? _k : this.debounceTime) !== null && _l !== void 0 ? _l : 2000;
        this.debouncedFlush = (_m = this.debouncedFlush) !== null && _m !== void 0 ? _m : debounce_1["default"](this.flush, this.debounceTime);
        this._requestImpl = (_p = (_o = config.request) !== null && _o !== void 0 ? _o : this._requestImpl) !== null && _p !== void 0 ? _p : request_1.fetchRequest;
        this.injectTimestamp = (_q = config.injectTimestamp) !== null && _q !== void 0 ? _q : false;
        this.shouldParseEventData = (_r = config.shouldParseEventData) !== null && _r !== void 0 ? _r : true;
        this.headers = {
            Authorization: "Splunk " + this.token
        };
    };
    /**
     * Exposes the implementation for the request function
     * used to send the events to the Splunk API.
     */
    SplunkEvents.prototype.request = function (fetchContext) {
        return this._requestImpl(fetchContext);
    };
    SplunkEvents.prototype.parseEventData = function (event) {
        var parsedEvent = '';
        for (var key in event) {
            if (Object.prototype.hasOwnProperty.call(event, key) &&
                event[key] != null) {
                var value = event[key];
                switch (typeof value) {
                    case 'string':
                        parsedEvent += key + "=\"" + value.replace(/"/g, '') + "\" ";
                        break;
                    case 'boolean':
                    case 'number':
                        parsedEvent += key + "=" + value + " ";
                        break;
                    default:
                        throw new Error('Event property must be string, number or boolean');
                }
            }
        }
        return parsedEvent;
    };
    SplunkEvents.prototype.validateEvent = function (event) {
        if (event === null) {
            throw new Error('Event must not be null');
        }
        if (event === undefined) {
            throw new Error('Event must not be undefined');
        }
        if (typeof event !== 'object') {
            throw new Error('Event must be an object');
        }
    };
    SplunkEvents.prototype.getAdditionalInfo = function () {
        if (typeof navigator === 'undefined' || typeof window === 'undefined') {
            return '';
        }
        var screen = window.screen, location = window.location;
        var additionalInfo = navigator.userAgent.replace(/,/g, ';') + "," +
            ((navigator.browserLanguage || navigator.language) + ",") +
            (navigator.platform + "," + (screen.availWidth || '-') + "," + (screen.availHeight || '-') + "," + location.hostname + ",") +
            (location.pathname + "," + location.protocol.replace(':', '') + "," + (location.hash || '-'));
        return {
            additional_info: additionalInfo
        };
    };
    SplunkEvents.prototype.formatEventsForSplunkBatch = function (events) {
        var splunkBatchedFormattedEvents = '';
        for (var i = 0; i < events.length; i++) {
            splunkBatchedFormattedEvents += "\n" + JSON.stringify(events[i]) + "\n";
        }
        return splunkBatchedFormattedEvents;
    };
    SplunkEvents.prototype.validateConfig = function () {
        if (this.token === null) {
            throw new Error('Token must not be null');
        }
        if (this.token === undefined) {
            throw new Error('Token must not be undefined');
        }
        if (this.endpoint === null) {
            throw new Error('endpoint must not be null');
        }
        if (this.endpoint === undefined) {
            throw new Error('endpoint must not be undefined');
        }
    };
    return SplunkEvents;
}());
exports["default"] = SplunkEvents;
